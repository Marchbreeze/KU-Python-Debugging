## 1. Software Development

- Software development의 4가지 P
    
    ![2024-09-17_00-44-13.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/edfd69d1-6c01-4d0c-9269-1bae8a4e3915/58623cdf-a101-4778-a112-bc12653858ca/2024-09-17_00-44-13.jpg)
    
    1. **Process (프로세스)**
        - 소프트웨어 개발에서 **활동의 집합** 또는 워크플로우
        - 프로젝트를 체계적으로 진행하는 방법론을 제공하며, 소프트웨어 개발의 전체적인 흐름을 정의
        - 주로 템플릿을 제공하여 프로젝트가 어떻게 진행되어야 하는지 지침을 제시하고, 도구를 지원하여 개발 활동을 더 효율적으로 수행할 수 있게 함
    2. **Project (프로젝트)**
        - 특정 소프트웨어를 개발하기 위한 **구체적인 작업**
        - 이는 요구사항에 따라 진행되며, 프로젝트의 결과는 제품(Product)으로 나타남
        - 프로젝트는 프로세스의 흐름을 따르고, 요구사항을 기반으로 사람들이 참여하여 진행
    3. **People (인력)**
        - 소프트웨어 개발에 참여하는 **사람 -**  고객, 사용자, 엔지니어 등 이해관계자(stakeholders)로 구성
        - 프로젝트의 모든 단계에서 중요한 역할을 하며, 요구사항을 제공하거나 소프트웨어를 직접 개발하고 유지하는 주체
    4. **Product (제품)**
        - 프로젝트의 결과물로서 **제품**
        - 모델, 코드, 매뉴얼 등 소프트웨어와 관련된 모든 산출물이 포함

## 2. 전통적 Software Development Process의 종류

- 대부분의 소프트웨어 개발 process는 시스템의 여러 공통적인 단계를 공유
    1. 요구사항 수집 (gathering the system requirements)
    2. 분석 및 설계 (analyzing and designing the system)
    3. 구현 (implementing the system)
    4. 테스트 (testing the system)
    5. **유지보수 (maintaining the system)**

- 각각의 개발 방식에 따라 **결합**되고, **강조**되는 부분이나 **수행 방법**이 달라질 수 있음
    1. 단계의 결합 (combined)
    2. 강조되는 요소 (emphasized)
    3. 단계 수행 방식 (carried out)

### (1) Code-and-fix

<aside>
💡

처음부터 명확한 요구사항이나 계획 없이 개발이 시작되고, 코드를 작성하면서 필요에 따라 기능을 추가하거나 수정하는 형태의 비체계적인 개발 방식

</aside>

![2024-09-24_17-58-26.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/edfd69d1-6c01-4d0c-9269-1bae8a4e3915/b835194f-84d0-433a-b6d2-fb4782a8d8a1/2024-09-24_17-58-26.jpg)

- 단점
    - 코드를 이해하고 유지보수하기 어려움
    - 개발 도중 예상하지 못한 요구사항이 자주 발생하게 되고, 이를 반영하기 위한 변경 사항이 반복적으로 추가
    - 소프트웨어 개발 프로세스가 예측 불가능하고 통제 불가능해짐
    - 인력 교체 시, 체계적인 문서화나 설계가 부족하기 때문에, 새로운 개발자가 기존 코드를 이해하는 데 큰 어려움
    - 일정 초과, 예산 초과, 낮은 품질 도출

⇒ 금지!

### (2) Waterfall

<aside>
💡

명확히 구분되는 단계에 따라 순차적으로 진행되는 체계적인 개발 방식

</aside>

![2024-09-24_18-02-46.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/edfd69d1-6c01-4d0c-9269-1bae8a4e3915/722dd199-692f-4f73-b4f2-0fa6f4f87ca3/2024-09-24_18-02-46.jpg)

- 장점
    1. 필요한 규율을 강제함 (엄격함과 형식성을 제공)
        - 각 단계에서 필요한 작업을 명확하게 정의
        - 다음 단계로 넘어가기 전에 이전 단계가 완료되어야 함
    2. 개발 프로세스를 예측 가능하고 모니터링하기 쉬움
        - 각 단계의 결과물과 일정이 명확히 정의되어 있어 진행 상황을 추적하고 관리하는 데 용이
    3. 표준화 강제
        - 각 단계마다 산출물(문서)을 생성 → 모든 과정이 명확히 기록
        - 각 단계가 완료되면 승인 절차가 필요 → 품질 기준 충족
    4. 다른 엔지니어링 프로세스 모델과 잘 맞음
        - 하드웨어 개발에서는 요구사항 변경이 매우 어렵고, 물리적인 제품이기 때문에 각 단계가 완료된 후에야 다음 단계로 넘어가는 방식이 효과적
- 단점
    1. 선형적인 개발을 가정
        - 중간에 되돌아가거나 수정하는 것이 매우 어려움
        - 요구사항이 명확하지 않거나 변화가 자주 발생하는 프로젝트에는 적합하지 않음
    2. 각 단계의 결과물이 고정되어야 함을 가정
        - 각 단계가 종료되면 결과물이 ‘동결’되어야 하므로, 요구사항 변경이나 설계 수정이 필요할 경우 전체 프로세스를 다시 거쳐야 하는 비효율성이 발생
    3. 모든 계획이 단일 제품 납품 날짜에 맞춰져 있음
        - 중간에 부분적인 기능을 제공하거나 피드백을 받을 기회가 적으며, 모든 계획이 하나의 최종 제품을 향해 진행
        - 제품이 최종 완성된 후에야 전체 시스템을 검증할 수 있기 때문에, 문제점이 뒤늦게 발견될 가능성이 큼

### (3) Prototyping

<aside>
💡

시제품을 제작하여 시스템의 주요 기능과 사용자 인터페이스를 미리 경험할 수 있게 하는 개발 방식

</aside>

![2024-09-24_18-09-04.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/edfd69d1-6c01-4d0c-9269-1bae8a4e3915/b676ae4a-5eef-416b-9fbe-1a8c4fbbcfbc/2024-09-24_18-09-04.jpg)

- 본질적으로 Code-and-Fix 방식과 유사하지만, 중요한 차이점과 규율이 존재
    - 좀 더 명확한 프로세스를 따라, 문서화와 같은 필수 산출물을 생성하는 등의 규율을 유지
    - 요구사항이 모호하거나 명확하지 않을 때, 사용자 인터페이스나 필요한 기능을 탐색할 수 있음
    - 일반적으로 프로토타입은 완성된 시스템이 아니며, 이를 그대로 사용하기보다는 새로운 시스템을 재구축
- 장점
    1. 요구사항을 빠르게 탐색
        - 초기 단계에서 요구사항을 확정하고, 필요한 기능을 파악
    2. 사용자 피드백과 승인을 얻을 수 있음
        - 사용자의 의견을 듣고, 이에 따라 기능이나 디자인을 수정 → 조기 피드백
    3. 다양한 해결책 탐색
        - 여러 가지 접근 방식을 시도해 볼 수 있으며, 그 중 가장 적합한 솔루션을 찾아낼 가능성이 높아짐
- 단점
    1. 완전한 소프트웨어 개발 프로세스가 아님
        - 프로토타입은 요구사항을 파악하거나 사용자 피드백을 받기 위한 도구일 뿐, 이 자체로 완성된 시스템을 만들 수 있는 것은 아님
    2. 최종 제품은 완전한 시스템이 아님
        - 시스템의 일부분만을 시뮬레이션하거나 구현한 것이기 때문에, 실제로 사용 가능한 완전한 시스템이 아님
    3. 일반적으로 시스템을 버리고 다시 구축함
        - 대부분의 경우 프로토타입을 버리고 처음부터 시스템을 다시 구축해야 함
        - 추가적인 개발 시간과 비용을 요구

### (4) Spiral

<aside>
💡

**위험 관리**를 중심으로 반복 주기(스파이럴)를 통해 시스템을 완성하는 개발 방법론

</aside>

![2024-09-25_01-37-12.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/edfd69d1-6c01-4d0c-9269-1bae8a4e3915/aa403a6d-0196-422c-b786-00c15138f487/2024-09-25_01-37-12.jpg)

- 위험 (Risk) = 성공을 위협할 수 있는 모든 요소
    1. 기술적 위험
        - 올바른 시스템을 구축하는 문제 : 시스템 요구사항을 정확하게 충족시키지 못할 위험
        - 시스템 아키텍처 문제 : 잘못된 아키텍처 선택으로 성능, 확장성 위험
        - 새로운 기술 사용 : 해당 기술이 제대로 작동하지 않거나 예상한 성능을 발휘하지 못할 수 있는 위험
        - 성능 문제 : 시스템의 성능이 예상보다 낮거나, 성능 요구사항을 충족하지 못할 위험
    2. 비기술적 위험
        - 전문 지식 부족: 특정 기술이나 도메인에 대한 전문성 확보 위험
        - 필요한 교육 부족: 새로운 기술이나 도구에 대해 충분한 교육을 받지 못할 위험
        - 빡빡한 일정: 개발 과정에서의 작은 지연도 전체 일정에 영향
        - 적시에 승인받기 어려움: 프로젝트가 지연되거나 방향을 잃을 위험

- 위험 대처 방법 (Dealing with Risks: ACMM)
    1. 피하기 (Avoid)
        - 위험을 미리 인식하고, 이를 회피하기 위한 계획을 세우거나 요구사항을 변경하는 방법
    2. 직면하기 (Confront)
        - 위험이 발생했을 때 그 영향을 최소화하도록 범위를 제한하는 방법
    3. 완화하기 (Mitigate)
        - 위험이 발생할 가능성을 줄이기 위한 조치를 미리 취하는 방법
    4. 모니터링하기 (Monitor)
        - 잠재적인 위험 요소를 지속적으로 감시하는 방법

- 장점
    1. 기존 프로세스의 장점을 수용하면서도 위험 관리로 문제를 줄임
        - waterfall 모델의 체계적이고 순차적인 접근 방식과 prototyping 모델의 반복적이고 사용자 중심의 개발 방식을 결합 & 위험관리로 워터폴의 경직성, 프로토타이핑의 불완전함 해소
    2.  프로젝트 초기에 재사용 가능성에 대한 분석과 탐색에 집중
        - 기존 모듈이나 코드의 재사용이 가능하다면 이를 적극 활용하여 개발 시간을 단축하고, 비용을 절감
    3. 조기에 오류와 약한 해결책 제거에 집중
        - 각 반복 주기(스파이럴)의 검토 단계에서 잠재적인 문제를 발견하고 수정
- 단점
    1. 외부 계약 개발보다는 내부 개발에 적합
        - 외부 계약 프로젝트에서는 요구사항이 명확하게 정의되고 고정된 상태에서 진행되는 경우가 많음
    2. 위험 평가에 대한 전문성에 의존
        - 프로젝트 팀 내에서 위험을 정확하게 식별하고 관리할 수 있는 전문 지식이 필요
    3. 각 반복 주기(스파이럴) 단계의 상세한 계획 필요

### (5) Phased

<aside>
💡

소프트웨어 개발을 **점진적**으로 진행하며, 여러 단계에 걸쳐 시스템을 완성하는 방법
부분적인 시스템을 먼저 개발한 후 점진적으로 확장하거나, 기능을 단계적으로 추가해 가면서 개발

</aside>

![2024-09-25_02-03-33.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/edfd69d1-6c01-4d0c-9269-1bae8a4e3915/9cbfec93-d4b3-4426-9ce2-e8e24a742831/2024-09-25_02-03-33.jpg)

- 접근법
    1. 점진적 개발 (Incremental Development)
        - 부분적인 시스템을 먼저 개발한 후 점진적으로 나머지 기능을 추가해 가는 방식
        - 일부분의 기능을 갖춘 시스템이 먼저 출시되고, 이후에 추가적인 기능이 점차적으로 보완
        
        ![2024-09-25_02-05-20.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/edfd69d1-6c01-4d0c-9269-1bae8a4e3915/fafed53f-7532-4b75-8df0-6b7280d9db72/2024-09-25_02-05-20.jpg)
        
    2. 반복적 개발 (Iterative Development)
        - 시스템의 전체 구조를 먼저 구현한 후, 기능을 점차적으로 개선하거나 확장해 나가는 개발 방식
        - 초기에는 완전한 시스템을 제공하지만, 기능이 제한적
        
        ![2024-09-25_02-05-31.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/edfd69d1-6c01-4d0c-9269-1bae8a4e3915/7b22bc10-baff-4d20-aa22-ac4c4f7c9840/2024-09-25_02-05-31.jpg)
        
- 장점
    1. 시스템 모듈화를 촉진
        - 모듈화된 시스템은 구조적으로 잘 짜여 있으며, 강력하고 유지보수하기 쉬운 시스템
    2. 프로젝트 실패 위험 감소
        - 점진적으로 개발하고 각 단계를 철저히 검토함으로써 프로젝트 실패의 위험을 줄임
    3. 조기 피드백 허용
        - 부분적인 기능을 먼저 사용자에게 제공하고 요구사항이나 기대에 맞는 기능을 개발
    4. 새로운 시장을 조기에 창출
        - 완전한 시스템을 기다리지 않고, 중요한 기능만을 먼저 제공함으로써 빠르게 시장 출시
    5. 빈번한 릴리즈 가능
        - 각 단계가 독립적으로 개발되고 테스트되기 때문에 자주 릴리즈 가능
    6. 적절한 전문 지식을 적용할 수 있음
        - 독립적으로 개발되기 때문에, 특정 모듈에 필요한 전문 지식을 가진 개발자나 팀을 배치 가능
- 단점
    1. 시스템 조각은 상대적으로 작아야 함
        - 큰 규모의 모듈을 한 번에 개발하면 점진적 개발의 장점이 사라질 수 있으며, 시스템이 복잡
    2. 모든 조각에 필요한 공통 기능 식별이 어려움
        - 미리 식별하고 적절하게 설계하지 않으면 나중에 시스템 통합 단계에서 문제가 발생

## 3. Agile & Lean Analytics

<aside>
💡

소프트웨어 개발 및 프로젝트 관리에서 유연하고 신속한 대응을 강조하는 방법론

</aside>

- Agile 방법론
    1. 우리의 최우선 과제는 가치 있는 소프트웨어의 `빠르고 지속적인 전달`을 통한 `고객 만족`
    2. 개발 후반부에서도 `요구사항 변경`을 환영 → 고객의 경쟁 우위를 위해 변화를 유연하게 수용
    3. 작동하는 소프트웨어를 몇 주에서 몇 달의 `짧은 주기`로 자주 전달
    4. 비즈니스 담당자와 개발자는 프로젝트 전반에 걸쳐 매일 `협력`
    5. `동기 부여`된 개인들로 프로젝트 구성 후 필요한 지원을 제공하고, 일을 해낼 것이라는 신뢰를 가지기
    6. 개발 팀 내에서 정보를 전달하는 가장 효율적이고 효과적인 방법은 `대면 대화`
    7. `작동하는 소프트웨어`가 진척의 주요 척도
    8. 유지보수를 통한 `지속 가능한 개발`을 촉진 → 후원자, 개발자, 사용자 모두 일정한 속도를 계속 유지
    9. `기술적 우수성`과 좋은 설계에 대한 지속적인 관심은 민첩성을 향상
    10. `단순함`, 즉 ‘하지 않은 작업을 최대화하는 기술’이 본질적
    11. 최고의 아키텍처, 요구사항, 설계는 자율적으로 `Self-organizaing Team`에서 나옴
    12. 정기적으로 팀은 더 효과적으로 일하는 방법을 `반성`하고, 이를 조율하고 행동을 조정

- Agile 선언문
    1. `개인 및 상호작용`을 프로세스 및 도구보다 중시합니다.
    2. `작동하는 소프트웨어`를 포괄적인 문서화보다 중시합니다.
    3. `고객과의 협력`을 계약 협상보다 중시합니다.
    4. `변화에 대응`하는 것을 계획을 따르는 것보다 중시합니다.

- Agile 방법론
    1. Extreme Programming (XP)
        - 빠르고 유연한 소프트웨어 개발을 목표로 하며, 특히 고객의 요구사항 변화에 신속하게 대응하고, 높은 소프트웨어 품질을 유지하기 위한 개발 방식을 강조
    2. 스크럼
        - 각 스프린트는 목표를 가지고 있으며, 그 목표를 달성하기 위해 개발팀이 작동 가능한 소프트웨어 또는 기능을 만들어 냄
        - Daily Scrum으로 팀원들이 어제 한 일, 오늘 할 일, 작업 중 발생한 장애물에 대해 간략히 공유
        - 스프린트가 끝나면, 새로운 기능이나 개선된 시스템을 고객에게 제공하여 피드백을 받고, 그에 따라 다음 스프린트를 계획
        - 팀워크와 협력을 통해 프로젝트를 성공적으로 수행할 수 있도록 도움
        
- Agile 실천방법
    1. Pair programing
        - 두 명의 개발자가 한 컴퓨터에서 협력하여 코드를 작성
    2. Test Driven Development (TDD)
        - 테스트 코드를 작성하고, 그 테스트를 통과할 수 있도록 실제 코드를 작성
    3. Planning poker
        - 팀이 함께 프로젝트의 작업 항목에 대한 **노력이나 복잡도를 추정**하는 데 사용

### (1) Extreme Programming (XP)

![2024-09-25_02-33-42.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/edfd69d1-6c01-4d0c-9269-1bae8a4e3915/f31346ec-640b-41be-8f66-b839ed3d0bc4/2024-09-25_02-33-42.jpg)

1. Planning
    - User Stories(사용자 스토리): 프로젝트에서 사용자 요구사항을 간단한 설명으로 표현한 것
    - Values(가치): 고객과 팀이 중요하게 생각하는 가치(예: 품질, 속도 등)를 반영
    - Acceptance Test Criteria(인수 테스트 기준): 사용자가 시스템이 동작한다고 인식할 기준을 설정
    - Iteration Plan(반복 계획): 각 반복 주기에 어떤 작업이 포함될지 계획하고 우선순위를 정함
2. Design
    - Simple Design(단순 설계): 복잡한 설계보다 단순하고 명확한 설계를 선호
    - CRC Cards(클래스-책임-협력 카드): 객체 지향 설계의 도구로, 각 클래스의 역할과 책임을 정의
    - Spike Solutions(스파이크 솔루션): 특정 기술적 문제를 해결하기 위해 빠르게 만든 시제품
    - Prototypes(프로토타입): 전체 시스템을 개발하기 전에 일부분을 구현하여 기능과 사용성을 테스트
3. Coding
    - Pair Programming(짝 프로그래밍): 두 명의 개발자가 한 컴퓨터에서 협력하여 코드를 작성하는 방식
    - Refactoring(리팩토링): 코드를 더 간결하고 효율적으로 만드는 작업
4. Test
    - Unit Test(단위 테스트): 작성한 코드의 개별 단위가 예상대로 동작하는지 확인하는 테스트
    - Continuous Integration(지속적인 통합): 개발자들이 작성한 코드를 자주 통합하고, 통합할 때마다 자동화된 테스트를 실행하여 전체 시스템이 정상적으로 동작하는지 확인
5. Release 
    - Software Increment(소프트웨어 증분): 각 반복 주기마다 새로운 기능을 포함한 소프트웨어를 배포
    - Project Velocity Computed(프로젝트 속도 계산): 개발 팀이 반복 주기마다 처리할 수 있는 작업량(속도)을 측정하여, 향후 작업 계획을 세우는 데 활용

### (2) Test Driven Development (TDD)

- 과정
    1. 테스트 작성: 요구되는 기능에 맞는 테스트를 먼저 작성
    2. 코드 작성: 테스트를 통과할 수 있도록 최소한의 코드를 작성
    3. 리팩토링(Refactoring): 테스트를 통과한 코드를 개선하거나 최적화
- 장점
    - 코드 품질 개선: 모든 코드가 테스트에 의해 검증되므로, 코드 품질이 향상되고 오류를 사전에 발견
    - 안정성: 코드를 리팩토링할 때도 테스트가 있으므로, 코드 변경이 기존 기능에 영향을 주지 않도록 보장
    - 유지보수 용이: 작성된 테스트가 일종의 문서 역할을 하여, 나중에 프로젝트를 유지보수하거나 새로운 기능을 추가할 때 유용

### (3) **Planning Poker**

- 과정
    1. 사용자 스토리 설명: Product Owner 또는 Scrum Master가 사용자 스토리(요구사항)를 설명
    2. 팀원들이 추정: 각 팀원이 각 사용자 스토리의 복잡도나 소요 시간을 추정
        - 팀원들은 Planning Poker 카드 덱을 사용하며, 카드에는 추정치를 나타내는 숫자가 적혀있음
    3. 카드 공개: 각 팀원이 동시에 카드를 뒤집어 자신의 추정치를 공개
    4. 토론: 추정치에 큰 차이가 있는 경우, 팀원들은 그 이유를 설명하고 토론, 이후 추정 작업 반복
    5. 합의: 팀원들이 의견을 모아 최종 추정치를 결정
- 장점
    - 협력적 추정: 모든 팀원이 추정에 참여하므로, 다양한 관점을 반영
    - 객관성 향상: 팀 내에서 의견이 큰 차이가 나는 경우 이를 논의함으로써, 더 객관적이고 현실적인 추정치에 도달
    - 빠른 추정: 팀원들이 동시에 추정 작업을 수행하므로, 전체 추정 과정을 빠르게 진행

### (4) Agile VS Waterfall

| Agile | Plan-driven (Waterfall) |
| --- | --- |
| • 낮은 치명도 | • 높은 치명도 |
| • 고급 개발자 | • 주니어 개발자 |
| • 요구사항이 매우 자주 변경됨 | • 요구사항이 자주 변경되지 않음 |
| • 소규모 개발자 팀 | • 대규모 개발자 팀 |
| • 혼란 속에서 번성하는 문화 | • 질서를 요구하는 문화 |
- Agile이 항상 유용한 것은 아님
    1. 주로 작은 규모의 프로젝트나 작은 팀에 적합하며, 그 안에서 높은 효율성을 보여줌
    2. 유연성을 중시하기 때문에 전통적인 개발 방법론에서 요구하는 구조나 문서화가 부족할 수 있음
    3. 경험이 풍부한 개발자가 있어야 효과적으로 운영될 수 있음
